<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book [
  <!ENTITY % book.entities SYSTEM "../book.entities">
  %book.entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
      xmlns:xlink = "http://www.w3.org/1999/xlink">

<title>GeoAPI</title>
  <para>
    Le projet <link xlink:href="http://www.geoapi.org">GeoAPI</link> offre un ensemble d’interfaces Java pour les applications géo-spatiales.
    Dans une séries de paquets <literal>org.opengis.*</literal>, GeoAPI &geoapi-release; définit des structures représentant des méta-données,
    des systèmes de référence des coordonnées, ainsi que des opérations effectuant des projections cartographiques.
    Dans une partie qui n’est pas encore standardisée — dénommée <foreignphrase>pending</foreignphrase> — GeoAPI définit des structures
    représentant des images géo-référencées, des géométries, des filtres pouvant s’appliquer à des requêtes, et d’autres fonctionnalités.
    Ces interfaces suivent de très près les spécifications de l’<acronym>OGC</acronym>, tout en les interprétant et en les adaptant
    de manière à répondre aux attentes des développeurs Java — par exemple en se conformant aux conventions de nommage.
    Ces interfaces bénéficient à la fois aux applications clientes et aux bibliothèques:
  </para>

  <itemizedlist>
    <listitem><para>
      Les développeurs des applications clientes bénéficient d’une plus grande base de connaissances disponible sur internet
      (due aux nombreuses publications en lien avec les standards de l’OGC), ainsi que d’une interopérabilité accrue.
      L’interopérabilité est facilitée par une meilleure séparation entre les applications qui <emphasis>appellent</emphasis> les fonctions de GeoAPI,
      et les bibliothèques qui <emphasis>implémentent</emphasis> GeoAPI. Il s’agit d’une séparation similaire à celle qu’offrent les interfaces
      <link xlink:href="http://docs.oracle.com/javase/7/docs/technotes/guides/jdbc/"><acronym>JDBC</acronym></link>
      (<foreignphrase>Java Database Connectivity</foreignphrase>) du Java standard.
      En utilisant l’<acronym>API</acronym> des interfaces, les développeurs peuvent faire abstraction de l’implémentation sous-jacente.
      Par exemple ils peuvent effectuer des projections cartographiques à l’aide des bibliothèques
      <link xlink:href="http://www.geoapi.org/geoapi-proj4/index.html">Proj.4</link> ou Geotoolkit.org,
      sans changer leurs programmes lorsqu’ils changent de bibliothèque.
    </para></listitem>
    <listitem><para>
      Les développeurs des bibliothèques héritent de l’expertise des auteurs des spécifications, via les modèles que représentent les interfaces.
      GeoAPI fournit aussi un cadre dans lequel les développeurs peuvent implémenter en priorité les fonctionnalité qui leurs sont le plus nécessaires,
      tout en ayant des points où raccrocher les développements futurs.
      Par exemple les clients peuvent appeler une fonction de GeoAPI même si elle n’est pas encore supportée par la bibliothèque,
      quitte à obtenir une valeur nulle en attendant qu’une nouvelle version de la bibliothèque retourne une valeur intéressante.
    </para></listitem>
  </itemizedlist>

<section>
  <title>Des spécifications aux interfaces</title>
  <para>
    Les standards de l’<acronym>OGC</acronym> étant définis par des moyens bien éprouvés en génie logiciel,
    il est possible de générer automatiquement des interfaces Java à l’aide d’outils relativement répandus.
    Une des approches les plus utilisées est de transformer les <link xlink:href="http://schemas.opengis.net/gml/&gml-version;/">schémas <acronym>XSD</acronym></link>
    en interfaces Java à l’aide de l’utilitaire en ligne de commande <command>xjc</command>.
    Cet utilitaire étant fournit avec la plupart des distributions du Java
    (il fait partie des outils de <link xlink:href="http://jaxb.java.net"><acronym>JAXB</acronym></link>),
    cette approche est choisie par plusieurs projets que l’on trouve sur internet.
    D’autres approches utilisent des outils intégrés à l’environnement de développement Eclipse, ou
    prennent comme point de départ les schémas <acronym>UML</acronym> plutôt que <acronym>XSD</acronym>.
  </para>
  <para>
    Une approche similaire avait été tentée dans les débuts du projet GeoAPI, mais a été rapidement abandonnée.
    Nous avons privilégié une approche manuelle pour les raisons suivantes:
  </para>

  <itemizedlist>
    <listitem><para>
      Certains schémas <acronym>XSD</acronym> sont beaucoup plus verbeux que les schémas <acronym>UML</acronym> d’origines.
      Une conversion à partir des schémas <acronym>XSD</acronym> introduit, au moins dans le cas des méta-données, près du
      double du nombre d’interfaces réellement définies par le standard, sans que cela n’apporte de nouvelles fonctionnalités.
      Une conversion à partir des schémas <acronym>UML</acronym> évite ce problème, mais les outils capable d’effectuer cette
      opération sont plus rares.
      </para>
      <informalexample><para>
        <emphasis role="bold">Exemple:</emphasis>
        Les schémas <acronym>XSD</acronym> des méta-données insèrent
        un élément <classname role="OGC">&lt;gmd:CI_Citation&gt;</classname> à l’intérieur de <function role="OGC">&lt;gmd:citation&gt;</function>,
        un élément <classname role="OGC">&lt;gmd:CI_OnlineResource&gt;</classname> à l’intérieur de <function role="OGC">&lt;gmd:onlineResource&gt;</function>,
        et ainsi de suite pour la centaine de classes définies dans le standard ISO 19115.
        Cette redondance n’est absolument pas nécessaire à un programme Java.
      </para></informalexample>
    </listitem>

    <listitem><para>
      Les standards de l’<acronym>OGC</acronym> utilisent des conventions de nommage qui sont différentes de celles du Java.
      En particulier les noms de presque toutes les classes de l’<acronym>OGC</acronym> commencent par un préfixe de deux lettres,
      comme dans <classname role="OGC">MD_Identifier</classname>. Ces préfixes jouent le rôle des noms de paquets en Java.
      GeoAPI adapte cette pratique en utilisant des noms d’interfaces sans préfixes,
      et en plaçant ces interfaces dans des paquets correspondants aux préfixes mais avec des noms plus descriptifs.
      Occasionnellement nous changeons aussi les noms, par exemple pour éviter des acronymes
      ou pour se conformer à une convention établie telle que <foreignphrase>Java beans</foreignphrase>.
      </para>
      <informalexample><para>
        <emphasis role="bold">Exemple:</emphasis>
        la classe <classname role="OGC">MD_Identifier</classname> de l’<acronym>OGC</acronym> devient
        l’interface <classname role="GeoAPI">Identifier</classname> dans le paquet <literal>org.opengis.metadata</literal>.
        La classe <classname role="OGC">SC_CRS</classname> de l’<acronym>OGC</acronym> devient l’interface <classname role="GeoAPI">CoordinateReferenceSystem</classname>,
        et l’association <function role="OGC">usesDatum</function> devient une méthode <function role="GeoAPI">getDatum()</function> —
        et non pas « <function>getUsesDatum()</function> » comme aurait fait un outil de conversion automatique.
        Nous ne laissons pas des programmes appliquer aveuglement des règles qui ignorent les conventions de la communauté dont on traduit les schémas.
      </para></informalexample>
    </listitem>

    <listitem><para>
      Les standards contiennent parfois des structures qui n’ont pas d’équivalent direct en Java,
      notamment les unions telles qu’on peut trouver en C/C++.
      La stratégie employée pour obtenir une fonctionnalité équivalente en Java dépend du contexte:
      multi-héritage des interfaces, modification de la hiérarchie ou simplement omettre l’union.
      Les décisions se font au cas-par-cas en fonction de l’analyse des besoins.
      </para>
      <informalexample><para>
        <emphasis role="bold">Exemple:</emphasis>
        Le standard ISO 19111 définit différents types de systèmes de coordonnées, tels que sphérique, cylindrique, polaire ou cartésien.
        Puis, il définit différents <emphasis>sous-ensembles</emphasis> de ces types de systèmes de coordonnées.
        Ces sous-ensembles, représentés par des unions, servent à spécifier qu’une classe peut être associée à seulement tel ou tel type de système de coordonnées.
        Par exemple l’union des types pouvant être associés à une image, nommée <classname role="OGC">CS_ImageCS</classname>,
        ne contient que <classname role="OGC">CS_CartesianCS</classname> et <classname role="OGC">CS_AffineCS</classname>.
        Dans ce cas particulier, nous obtenons en Java l’effet souhaité par une modification de la hiérarchie des classes:
        nous définissons l’interface <classname role="GeoAPI">CartesianCS</classname> comme une spécialisation de <classname role="GeoAPI">AffineCS</classname>, ce qui est sémantiquement correct.
        Mais il n’est pas possible d’appliquer une stratégie similaire pour les autres unions sans violer la sémantique.
      </para></informalexample>
    </listitem>

    <listitem><para>
      Plusieurs spécifications se chevauchent. GeoAPI effectue un travail d’intégration en remplaçant certaines
      structures qui font doublons par des références vers les structures équivalentes du standard qui les définies le mieux.
      </para>
      <informalexample><para>
        <emphasis role="bold">Exemple:</emphasis>
        Le standard ISO 19115, qui définit des structures de méta-données,
        s’aventure aussi à décrire quelques structures représentant les systèmes de références des coordonnées (<acronym>CRS</acronym>).
        Or ces derniers sont le sujet à part entière d’un autre standard: ISO 19111.
        D’ailleurs le standard ISO 19111:2007 stipule, dans sa section 3, qu’il réutilise tous les éléments
        de ISO 19115 à l’exclusion de <classname role="OGC">MD_CRS</classname> et de ses composantes.
        Les interfaces de GeoAPI réduisent la redondance en appliquant à l’ensemble du projet l’exclusion recommandée par ISO 19111.
      </para></informalexample>
    </listitem>

    <listitem><para>
      Certains standards ont vu leur complexité s’accroître pour des raisons historiques plutôt que techniques,
      liées au processus de standardisation. GeoAPI réduit la dette technique en concevant les interfaces comme
      si chaque élément avait pu être intégrée à sa place, sans les contraintes liées à l’ordre chronologique
      dans lequel les standards ont été publiés.
      </para>
      <informalexample><para>
        <emphasis role="bold">Exemple:</emphasis>
        Le standard ISO 19115-2 est une extension du standard ISO 19115-1 ajoutant des structures de méta-données d’images.
        Ces méta-données ont été définies dans un standard séparé parce qu’elles n’ont pas été prêtes à temps pour la publication de la première partie du standard.
        Comme il n’était pas possible, pour des raisons administratives, d’ajouter des attributs dans les classes déjà publiées,
        les nouveaux attributs ont été ajoutées dans une sous-classe portant quasiment le même nom.
        Ainsi, le standard ISO 19115-2 définit une classe <classname role="OGC">MI_Band</classname> qui étend la
        classe <classname role="OGC">MD_Band</classname> du standard ISO 19115-1 en y ajoutant les attributs qui
        auraient du apparaître directement dans la classe parente s’ils avaient été prêts à temps.
        Dans GeoAPI, nous avons choisis de « réparer » ces anomalies en fusionnant ces deux classes en une seule interface.
      </para></informalexample>
    </listitem>
  </itemizedlist>

  <para>
    Les écarts par rapport aux normes sont documentés dans chaque classe et chaque méthode concernées.
    Chaque mention d’un écart est aussi recopiée dans <link xlink:href="&geoapi-javadoc;/departures.html">une page unique</link>,
    pour donner une vue d’ensemble.
  </para>

</section>
</chapter>
